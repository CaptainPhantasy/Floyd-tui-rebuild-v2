import { create } from 'zustand';
import { saveState, loadState as loadPersistedState, clearState as clearPersistedState, initializeState } from '../utils/persistence.js';
import { getRandomPhraseUnique } from '../utils/whimsical-phrases.js';

export type OverlayMode = 'none' | 'transcript' | 'history' | 'background' | 'command' | 'help' | 'config' | 'context' | 'editor';

export type FloydMode = 'yolo' | 'ask' | 'plan' | 'auto' | 'dialogue' | 'fuckit';

export type ConnectionStatus = 'online' | 'offline' | 'connecting';

interface BackgroundTask {
  id: string;
  command: string;
  status: 'running' | 'done' | 'failed';
  startTime: number;
  endTime?: number;
  exitCode?: number;
  output?: string;
}

export interface ChatMessage {
  id: string;
  role: 'user' | 'assistant' | 'system' | 'tool';
  content: string;
  timestamp: number;
  streaming?: boolean;
  toolCalls?: ToolCall[];
}

interface ToolCall {
  name: string;
  status: 'pending' | 'running' | 'success' | 'error';
  result?: string;
  error?: string;
}

interface TuiStore {
  mode: FloydMode;
  model: string;
  provider: string;
  connectionStatus: ConnectionStatus;
  isThinking: boolean;
  thinkingEnabled: boolean;
  whimsicalPhrase: string | null;
  messages: ChatMessage[];
  streamingContent: string;
  overlayMode: OverlayMode;
  backgroundTasks: BackgroundTask[];
  _initialized: boolean;
  llmClient?: any;

  setMode: (mode: FloydMode) => void;
  cycleMode: () => void;
  setModel: (model: string) => void;
  setProvider: (provider: string) => void;
  setConnectionStatus: (status: ConnectionStatus) => void;
  setThinking: (thinking: boolean, phrase?: string) => void;
  toggleThinking: () => void;
  addMessage: (message: ChatMessage) => void;
  clearMessages: () => void;
  exportTranscript: () => void;
  setStreamingContent: (content: string) => void;
  setOverlayMode: (mode: OverlayMode) => void;
  closeOverlay: () => void;
  addBackgroundTask: (task: Omit<BackgroundTask, 'id'>) => string;
  updateBackgroundTask: (id: string, updates: Partial<BackgroundTask>) => void;
  sendMessage: (content: string) => Promise<string>;
  undoLastExchange: () => void;
  // Persistence actions
  initialize: () => Promise<void>;
  savePreferences: () => Promise<void>;
  loadPreferences: () => Promise<void>;
  clearPreferences: () => Promise<void>;
}

export const useTuiStore = create<TuiStore>((set, get) => ({
  mode: 'yolo',
  model: 'glm-4-plus',
  provider: 'glm',
  connectionStatus: 'offline',
  isThinking: false,
  thinkingEnabled: true,
  whimsicalPhrase: null,
  messages: [],
  streamingContent: '',
  overlayMode: 'none',
  backgroundTasks: [],
  _initialized: false,
    const currentIdx = modes.indexOf(get().mode);
    const nextMode = modes[(currentIdx + 1) % modes.length];
    set({ mode: nextMode });
    saveState({ mode: nextMode }).catch(() => {});
  },
   llmClient: undefined,
    const nextMode = modes[(currentIdx + 1) % modes.length];
    set({ mode: nextMode });
    saveState({ mode: nextMode }).catch(() => {});
  },
  setModel: (model) => {
    set({ model });
    saveState({ model }).catch(() => {});
  },
  setProvider: (provider) => {
    set({ provider });
    saveState({ provider }).catch(() => {});
  },
  setConnectionStatus: (connectionStatus) => set({ connectionStatus }),

  setThinking: (isThinking, whimsicalPhrase) => {
    const phrase = isThinking && !whimsicalPhrase
      ? getRandomPhraseUnique(get().whimsicalPhrase ?? undefined)
      : whimsicalPhrase;
    set({ isThinking, whimsicalPhrase: phrase ?? null });
  },
  toggleThinking: () => {
    const newState = !get().thinkingEnabled;
    set({ thinkingEnabled: newState });
    saveState({ thinkingEnabled: newState }).catch(() => {});
  },

  addMessage: (message) => set((state) => ({
    messages: [...state.messages, message],
  })),
  clearMessages: () => set({ messages: [] }),
  exportTranscript: () => {
    const { messages } = get();
    const timestamp = new Date().toISOString();
    const filename = `floyd-transcript-${timestamp}.txt`;
    const content = messages.map(m =>
      `[${new Date(m.timestamp).toISOString()}] ${m.role.toUpperCase()}: ${m.content}`
    ).join('\n\n');
    // In a real implementation, this would write to a file
    // For now, we'll just log it
    console.log(`\n--- Export to ${filename} ---\n${content}\n`);
  },
  setStreamingContent: (streamingContent) => set({ streamingContent }),

  setOverlayMode: (overlayMode) => set({ overlayMode }),
  closeOverlay: () => set({ overlayMode: 'none' }),

  addBackgroundTask: (task) => {
    const id = Math.random().toString(36).substring(7);
    set((state) => ({
      backgroundTasks: [...state.backgroundTasks, { ...task, id }],
    }));
    return id;
  },
  updateBackgroundTask: (id, updates) => set((state) => ({
    backgroundTasks: state.backgroundTasks.map((task) =>
      task.id === id ? { ...task, ...updates } : task
    ),
  })),

  sendMessage: async (content) => {
    const userMessage: ChatMessage = {
      id: Math.random().toString(36).substring(7),
      role: 'user',
      content,
      timestamp: Date.now(),
    };
    const phrase = getRandomPhraseUnique(get().whimsicalPhrase ?? undefined);

    // Add user message immediately
    set({
      messages: [...get().messages, userMessage],
      isThinking: true,
      whimsicalPhrase: phrase,
    });

    // Get LLM client and send message
    const { createLLMClient } = await import('../llm/factory.js');
    const client = createLLMClient('glm', {
      apiKey: process.env.GLM_API_KEY || 'demo-key',
    });

    try {
      const response = await client.sendMessage(content);

      // Add assistant response
      const assistantMessage: ChatMessage = {
        id: Math.random().toString(36).substring(7),
        role: 'assistant',
        content: response,
        timestamp: Date.now(),
      };

      set((state) => ({
        messages: [...state.messages, assistantMessage],
        isThinking: false,
      }));

      return response;
    } catch (error) {
      console.error('Failed to send message:', error);
      set({ isThinking: false });
      throw error;
    }
  },
  undoLastExchange: () => set((state) => ({
    messages: state.messages.slice(0, -2),
  })),

  // Persistence actions
  initialize: async () => {
    if (get()._initialized) return;

    const cached = await initializeState();
    if (cached.mode) set({ mode: cached.mode });
    if (cached.thinkingEnabled !== undefined) set({ thinkingEnabled: cached.thinkingEnabled });
    if (cached.provider) set({ provider: cached.provider });
    if (cached.model) set({ model: cached.model });
    if (cached.recentMessages) set({ messages: cached.recentMessages });

    set({ _initialized: true });
  },

  savePreferences: async () => {
    const { mode, thinkingEnabled, provider, model } = get();
    await saveState({ mode, thinkingEnabled, provider, model });
  },

  loadPreferences: async () => {
    const cached = await loadPersistedState();
    if (cached.mode) set({ mode: cached.mode });
    if (cached.thinkingEnabled !== undefined) set({ thinkingEnabled: cached.thinkingEnabled });
    if (cached.provider) set({ provider: cached.provider });
    if (cached.model) set({ model: cached.model });
    if (cached.recentMessages) set({ messages: cached.recentMessages });
  },

  clearPreferences: async () => {
    await clearPersistedState();
    // Reset to defaults
    set({
      mode: 'yolo',
      thinkingEnabled: true,
      provider: 'glm',
      model: 'glm-4-plus',
    });
  },
}));
